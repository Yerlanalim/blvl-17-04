# Оптимизация карты уровней

## Выявленные проблемы
- Избыточный рендеринг при большом количестве уровней (особенно на слабых устройствах)
- Медленные запросы к Firestore при отсутствии кэша
- Задержки анимаций и лаги при масштабировании карты
- Повышенное потребление памяти при больших картах

## Применённые решения
- Внедрено кэширование уровней и связей (CacheManager, LevelMapCache)
- Использована мемоизация для повторяющихся вычислений (Memoizer)
- Добавлен RepaintBoundary для изоляции перерисовок интерактивных элементов
- Реализована виртуализация рендеринга видимых элементов (отображаются только элементы в viewport)
- Оптимизированы запросы к Firestore: минимизация объёма, пагинация, агрегация
- Профилированы анимации, снижена нагрузка на GPU
- Добавлены const-виджеты и оптимизированы build-методы

## Рекомендации
- Использовать const-виджеты для минимизации рендеринга
- Применять RepaintBoundary для изоляции перерисовок
- Использовать мемоизацию для повторяющихся вычислений
- Оптимизировать запросы к Firestore с помощью кэширования и пагинации
- Реализовать виртуализацию для больших карт (например, через flutter_staggered_grid_view)
- Профилировать анимации и оптимизировать их для плавности
- Следить за потреблением памяти на мобильных устройствах
- Использовать Flutter DevTools для анализа производительности
- Для слабых устройств предусмотреть деградацию функциональности (отключение сложных анимаций)

## Примеры кода

**Мемоизация:**
```dart
class Memoizer<T, R> {
  final _cache = <T, R>{};
  R memoize(T arg, R Function(T) compute) {
    if (_cache.containsKey(arg)) return _cache[arg]!;
    final result = compute(arg);
    _cache[arg] = result;
    return result;
  }
}
```

**Использование RepaintBoundary:**
```dart
RepaintBoundary(
  child: LevelNodeWidget(...),
)
```

**Виртуализация (пример):**
```dart
ListView.builder(
  itemCount: visibleNodes.length,
  itemBuilder: (context, index) {
    return LevelNodeWidget(...);
  },
)
```
